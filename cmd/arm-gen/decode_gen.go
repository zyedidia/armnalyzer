//go:build ignore

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/zyedidia/armvis/mra"
)

func xMask(bits string) string {
	mask := &bytes.Buffer{}
	mask.WriteString("0b")
	for _, c := range bits {
		switch c {
		case 'x':
			mask.WriteByte('0')
		default:
			mask.WriteByte('1')
		}
	}
	return mask.String()
}

func GenerateRegParseExpr(diagram string) string {
	parts := strings.Split(diagram, "|")
	b := 0
	buf := &bytes.Buffer{}
	first := true
	for i := len(parts) - 1; i >= 0; i-- {
		not := false
		_, bits, found := strings.Cut(parts[i], "=")
		if !found {
			_, bits, found = strings.Cut(parts[i], "!=")
			if found {
				not = true
			} else {
				bits = parts[i]
			}
		}

		if strings.Count(bits, "x") != len(bits) {
			mask := xMask(bits)

			var expr string
			if !not {
				expr = fmt.Sprintf("((insn >> %d) & %s) == 0b%s", b, mask, strings.ReplaceAll(bits, "x", "0"))
			} else {
				expr = fmt.Sprintf("((insn >> %d) & %s) != 0b%s", b, mask, bits)
			}
			if first {
				first = false
			} else {
				fmt.Fprint(buf, "&&")
			}
			fmt.Fprintf(buf, "(%s)", expr)
		}

		b += len(bits)
	}
	return buf.String()
}

func GenerateRegParseFunc(i int, diagram string) string {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "func parse_%d(insn uint32) bool {\n", i)
	fmt.Fprintf(buf, "\treturn %s\n", GenerateRegParseExpr(diagram))
	fmt.Fprintf(buf, "}\n")
	return buf.String()
}

func GenerateRegParseFuncJS(i int, diagram string) string {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "function parse_%d(insn) {\n", i)
	fmt.Fprintf(buf, "\treturn %s;\n", GenerateRegParseExpr(diagram))
	fmt.Fprintf(buf, "}\n")
	return buf.String()
}

func GenerateRegParseFuncCBase(i int, diagram string) string {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "static bool parse_%d(uint32_t insn) {\n", i)
	fmt.Fprintf(buf, "\treturn %s;\n", GenerateRegParseExpr(diagram))
	fmt.Fprintf(buf, "}\n")
	return buf.String()
}

func main() {
	js := flag.Bool("js", false, "emit javascript")
	cbase := flag.Bool("cbase", false, "emit C for matching ARMv8.0 base")

	flag.Parse()
	args := flag.Args()

	if len(args) <= 0 {
		log.Fatal("no input")
	}
	b, err := os.ReadFile(args[0])
	if err != nil {
		log.Fatal(err)
	}
	var records []mra.Record
	err = json.Unmarshal(b, &records)
	if err != nil {
		log.Fatal(err)
	}

	if *js {
		fmt.Println("var funcs = [")
		for i := range records {
			fmt.Printf("\tparse_%d,\n", i)
		}
		fmt.Println("]")
		for i, r := range records {
			fmt.Println(GenerateRegParseFuncJS(i, r.RegDiagram))
		}
		return
	}

	if *cbase {
		fmt.Println("#include <stdbool.h>")
		fmt.Println("#include <stdint.h>")
		for i, r := range records {
			if r.Variants != "" {
				continue
			}
			fmt.Println(GenerateRegParseFuncCBase(i, r.RegDiagram))
		}

		fmt.Println("bool (*funcs[])(uint32_t) = {")
		n := 0
		for i, r := range records {
			if r.Variants != "" {
				continue
			}
			fmt.Printf("&parse_%d,\n", i)
			n++
		}
		fmt.Println("};")
		fmt.Printf("uint64_t n_funcs = %d;\n", n)
		return
	}

	fmt.Println("// Code generated by decode_gen arm64.json; DO NOT EDIT")
	fmt.Println("package main")
	fmt.Println()
	fmt.Println("var funcs = []func(uint32) bool{")
	for i := range records {
		fmt.Printf("\tparse_%d,\n", i)
	}
	fmt.Println("}")

	for i, r := range records {
		fmt.Println(GenerateRegParseFunc(i, r.RegDiagram))
	}
}
